const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./D_UVa_SS.js","./i7_vV6_l.js","./CcsFqX96.js"])))=>i.map(i=>d[i]);
import{w as m,d as h}from"./i7_vV6_l.js";import{_ as l}from"./C1FmrZbK.js";const A="http://localhost:8000",O=1e4,P=3,D=6e4,C=16e3,T=16e3,j=["audio/webm;codecs=opus","audio/webm","audio/mp4","audio/ogg;codecs=opus"],g="QuickCaptureDB",y=1,f="captures",w=3e3,x={OFFLINE:"您当前处于离线状态，内容已保存到本地",NETWORK_ERROR:"网络连接失败，请稍后重试",PERMISSION_DENIED:"需要麦克风权限才能录音",RECORDING_ERROR:"录音失败，请检查麦克风设置",API_ERROR:"API请求失败，请稍后重试",TIMEOUT:"请求超时，请检查网络连接"},M={CAPTURE_SAVED:"✅ 想法已保存",VOICE_CAPTURED:"✅ 语音已转录并保存",SYNC_COMPLETE:"✅ 数据同步完成"};function p(){return`${Date.now()}-${Math.random().toString(36).substr(2,9)}`}function U(i){return new Promise(r=>setTimeout(r,i))}function E(){const{subscribe:i,set:r,update:o}=m({toasts:[],showInstallPrompt:!1,theme:"dark",sidebarOpen:!1});return{subscribe:i,showToast(t,e="info",s=w){const n={id:p(),message:t,type:e,timestamp:Date.now()};o(a=>({...a,toasts:[...a.toasts,n]})),setTimeout(()=>{o(a=>({...a,toasts:a.toasts.filter(c=>c.id!==n.id)}))},s)},removeToast(t){o(e=>({...e,toasts:e.toasts.filter(s=>s.id!==t)}))},clearToasts(){o(t=>({...t,toasts:[]}))},showInstallPromptDialog(){o(t=>({...t,showInstallPrompt:!0}))},hideInstallPromptDialog(){o(t=>({...t,showInstallPrompt:!1}))},toggleTheme(){o(t=>({...t,theme:t.theme==="dark"?"light":"dark"}))},setTheme(t){o(e=>({...e,theme:t}))},toggleSidebar(){o(t=>({...t,sidebarOpen:!t.sidebarOpen}))},closeSidebar(){o(t=>({...t,sidebarOpen:!1}))}}}const q=E();class I{constructor(){this.db=null,this.dbName=g,this.dbVersion=y,this.storeName=f}async init(){return new Promise((r,o)=>{const t=indexedDB.open(this.dbName,this.dbVersion);t.onerror=()=>{console.error("IndexedDB error:",t.error),o(t.error)},t.onsuccess=()=>{this.db=t.result,console.log("IndexedDB initialized successfully"),r()},t.onupgradeneeded=e=>{const s=e.target.result;if(!s.objectStoreNames.contains(this.storeName)){const n=s.createObjectStore(this.storeName,{keyPath:"id",autoIncrement:!1});n.createIndex("timestamp","timestamp",{unique:!1}),n.createIndex("synced","synced",{unique:!1}),n.createIndex("type","type",{unique:!1}),console.log("Object store created:",this.storeName)}}})}async addCapture(r){this.db||await this.init();const o={id:p(),...r,timestamp:Date.now(),synced:!1,offline:!0};return new Promise((t,e)=>{const a=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName).add(o);a.onsuccess=()=>{console.log("Capture added to IndexedDB:",o.id),t(o.id)},a.onerror=()=>{console.error("Failed to add capture:",a.error),e(a.error)}})}async getUnsyncedCaptures(){return this.db||await this.init(),new Promise((r,o)=>{const n=this.db.transaction([this.storeName],"readonly").objectStore(this.storeName).index("synced").getAll(!1);n.onsuccess=()=>{console.log("Unsynced captures:",n.result.length),r(n.result)},n.onerror=()=>{console.error("Failed to get unsynced captures:",n.error),o(n.error)}})}async markAsSynced(r){return this.db||await this.init(),new Promise((o,t)=>{const s=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName),n=s.get(r);n.onsuccess=()=>{const a=n.result;if(a){a.synced=!0,a.syncedAt=Date.now();const c=s.put(a);c.onsuccess=()=>{console.log("Capture marked as synced:",r),o()},c.onerror=()=>{console.error("Failed to mark as synced:",c.error),t(c.error)}}else console.warn("Record not found:",r),o()},n.onerror=()=>{console.error("Failed to get record:",n.error),t(n.error)}})}async getAllCaptures(r=100){return this.db||await this.init(),new Promise((o,t)=>{const a=this.db.transaction([this.storeName],"readonly").objectStore(this.storeName).index("timestamp").openCursor(null,"prev"),c=[];a.onsuccess=b=>{const d=b.target.result;d&&c.length<r?(c.push(d.value),d.continue()):(console.log("Retrieved captures from IndexedDB:",c.length),o(c))},a.onerror=()=>{console.error("Failed to get all captures:",a.error),t(a.error)}})}async deleteCapture(r){return this.db||await this.init(),new Promise((o,t)=>{const n=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName).delete(r);n.onsuccess=()=>{console.log("Capture deleted:",r),o()},n.onerror=()=>{console.error("Failed to delete capture:",n.error),t(n.error)}})}async clearAll(){return this.db||await this.init(),new Promise((r,o)=>{const s=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName).clear();s.onsuccess=()=>{console.log("All captures cleared from IndexedDB"),r()},s.onerror=()=>{console.error("Failed to clear captures:",s.error),o(s.error)}})}async getStats(){return this.db||await this.init(),new Promise((r,o)=>{const e=this.db.transaction([this.storeName],"readonly").objectStore(this.storeName),s=e.count();s.onsuccess=()=>{const n=s.result,c=e.index("synced").count(!1);c.onsuccess=()=>{r({total:n,unsynced:c.result,synced:n-c.result})},c.onerror=()=>{o(c.error)}},s.onerror=()=>{console.error("Failed to get stats:",s.error),o(s.error)}})}close(){this.db&&(this.db.close(),this.db=null,console.log("IndexedDB connection closed"))}}const u=new I;function _(){const{subscribe:i,set:r,update:o}=m({online:navigator.onLine,syncing:!1,lastSyncTime:null,pendingCount:0});typeof window<"u"&&(window.addEventListener("online",()=>{console.log("Network: Online"),o(e=>({...e,online:!0})),t()}),window.addEventListener("offline",()=>{console.log("Network: Offline"),o(e=>({...e,online:!1}))}));async function t(){try{const e=await u.getStats();if(e.unsynced>0){console.log(`Auto-syncing ${e.unsynced} unsynced captures`);const{captureStore:s}=await l(async()=>{const{captureStore:n}=await import("./D_UVa_SS.js");return{captureStore:n}},__vite__mapDeps([0,1,2]),import.meta.url);await s.syncOfflineCaptures()}}catch(e){console.error("Auto-sync error:",e)}}return{subscribe:i,setSyncing(e){o(s=>({...s,syncing:e}))},updateLastSyncTime(){o(e=>({...e,lastSyncTime:Date.now()}))},incrementPending(){o(e=>({...e,pendingCount:e.pendingCount+1}))},decrementPending(){o(e=>({...e,pendingCount:Math.max(0,e.pendingCount-1)}))},setPendingCount(e){o(s=>({...s,pendingCount:e}))},async refreshPendingCount(){try{const e=await u.getStats();o(s=>({...s,pendingCount:e.unsynced}))}catch(e){console.error("Failed to refresh pending count:",e)}},async manualSync(){const{captureStore:e}=await l(async()=>{const{captureStore:s}=await import("./D_UVa_SS.js");return{captureStore:s}},__vite__mapDeps([0,1,2]),import.meta.url);await e.syncOfflineCaptures()}}}const S=_();h(S,i=>!i.online);const B=h(S,i=>i.pendingCount>0);export{C as A,x as E,D as M,M as S,j as a,T as b,A as c,O as d,P as e,U as f,u as g,B as h,S as s,q as u};
